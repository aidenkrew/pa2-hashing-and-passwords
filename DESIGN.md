Real password crackers try many more variations than just uppercasing and lowercasing. Do a little research on password cracking and suggest at least 2 other ways to vary a password to crack it. Describe them both, and for each, write a sentence or two about what modifications you would make to your code to implement them.

One way I could vary a password to crack it could replace characters with common look alike numbers. For example, an 'E' or an 'e' could be replaced with a 3 or a 'S' or 's' could be replaced by a '$'. The way we could implement this is possible just adding a couple of if statements to check for these letters and replace that index of the string in my test variable in the function with the corresponding look alike character for it.

Another way to vary a password could be to replace each letter with characters around it on the keyboard to test for any typos. For example, if my password was "password", with every character like for the "o", you could check and replace that character with an 'i' or a 'p' to see maybe if there was any typos. This would be a little harder to implement since there would be many possibilites. One way you could implement it, although probably inefficient, just do many if statments considering each character, and checking the characters next to each character on the keyboard.

How much working memory is needed to store all of the variables needed to execute the password cracker? Based on your response would you say that a password cracker is more memory-limited or is it more limited by how fast the process can run the code?

It's a little confusing on what exactly this means but for my program, looking at all the bytes I allocated for the arrays, there is 64 bytes for the SHA256 hash, and then 32 bytes for the given_hash array + another 32 bytes for checking the hash, and then the 3 arrays for the password length + 1 for the null terminator so 257 x 3, 1 for the actual password, 1 for the correct password, and 1 for the test password when in the crack password function. So in total it just 64 + 32 + 32 + (257 x 3) = 899 bytes. I don't think thats a lot of bytes (but I don't have the intuition for it yet) so it would be more limited by how fast the process can run the code.
